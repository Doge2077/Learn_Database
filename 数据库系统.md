# 1. 绪论

****

## 1.1 数据库系统概述

****

### 1.1.1 基本概念

****

#### 数据（data）

* 数据是数据库中存储的基本对象。
* 描述事物的符号记录称为数据。
* 数据有多种表现形式，它们都可以经过数字化之后存入计算机。


数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的。

数据的解释是指对数据含义的说明，数据的含义称为**数据的语义**，数据与其语义是不可分的。

****

#### 数据库（DataBase, DB）

* 数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。
* 数据库中的数据按一定的数据模型组织、描述和储存，具有以下特点：
  * 较小的冗余度（redundancy）
  * 较高的数据独立性（data independency）
  * 易扩展性（scalability）
  * 可为各种用户共享

  概括地讲，数据库数据具有永久存储、有组织和可共享三个基本特点。

****

#### 数据库管理系统（DataBase Management System, DBMS）

  数据库管理系统是位于用户与操作系统之间的一层**数据管理软件**。**数据库管理系统和操作系统一样是计算机的基础软件**，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面：

* 数据定义功能：
  * 提供数据定义语言（Data Definition Language, DDL）可对数据库中的数据对象的组成与结构进行定义。
* 数据组织、存储和管理：
  * 数据库管理系统要分类组织、存储和管理各种数据；
  * 提高存储空间利用率和方便存取，提供多种存取方法来提高存取效率。
* 数据操纵功能：
  * 提供数据操纵语言（Data Manipulation Language, DML）可操纵数据，实现对数据库的增删改查等。
* 数据库的事务管理和运行管理：
  * 数据库在建立、运用和维护时由数据库管理系统统一管理和控制；
  * 保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。
* 数据库的建立和维护功能：
  * 包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。
* 其他功能：
  * 包括数据库管理系统与网络中其他软件系统的通信功能；
  * 一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能；
  * 异构数据库之间的互访和互操作功能等。

****

#### 数据库系统（DataBase System, DBS）

* 由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator，DBA）组成的存储、管理、处理和维护数据的系统。
* 数据库的建立、使用和维护等工作只靠一个数据库管理系统远远不够，还要有专门的人员来完成，这些人被称为数据库管理员。

![](L:\02 学习笔记\数据库系统\图片1\概念.png)

****

### 1.1.2 数据管理技术的产生和发展

****

![](L:\02 学习笔记\数据库系统\图片1\阶段发展.png)

****

### 1.1.3 数据库系统的特点

****

* 数据结构化：
  *  **数据库系统实现整体数据的结构化，是数据库系统与文件系统的本质区别。**
  * 所谓“整体”结构化，不仅数据内部是结构化的，而且数据整体是结构化的，数据之间是具有联系的。
* 数据的共享性高、冗余度低且易扩充：
  * 数据可以被多个用户、多个应用共享使用，数据共享可以大大减少数据冗余，节约存储空间。
  * 避免数据之间的不相容性与不一致性。
* 数据独立性高：
  * 物理独立性：用户的应用程序与数据库中数据的物理存储是相互独立的。
  * 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。
* 数据由数据库管理系统统一管理和控制：
  * 保证数据的安全性（security），数据的完整性（integrity），支持并发（concurrency）和数据库恢复（recovery）。

  **总结**：数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。

****

## 1.2  数据模型

****

### 1.2.1 两种数据模型

****

  数据模型（data model）也是一种模型，它是对现实世界数据特征的抽象，**数据模型是数据库系统的核心和基础。**

  数据模型应满足三方面要求：

* 能比较真实地模拟现实世界。
* 容易为人所理解。
* 便于在计算机上实现。

****

#### 概念模型

****

  第一类概念模型（conceptual model），也称信息模型，它是按用户的观点来对数据和信息建模，使用简单的符号来描述信息，没有严格的规定，只要能清晰反映现实世界的信息就行，主要用于数据库设计。

****

#### 逻辑模型

****

  第二类中的逻辑模型主要包括层次模型（hierarchical model）、网状模型（network model）、关系模型（relational model）、面向对象数据模型（object oriented data model）和对象关系数据模型（object relational data model）、半结构化数据模型（semistructured data model）等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。

  第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。物理模型的具体实现是数据库管理系统的任务。

![](L:\02 学习笔记\数据库系统\图片1\抽象.png)

****

### 1.2.2 概念模型

****

#### 基本概念

****

- 实体（Entity）：客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。
- 属性（Attribute）：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。
- 码（Key）：唯一标识实体的属性集称为码。
- 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。
  * 例如：学生（学号，姓名，性别，出生年月，所在院系，入学时间）
- 实体集（Entity Set）：同型实体的集合称为实体集.
  * 例如：2021级计算机学院的全体学生。
- 联系（Relationship）：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。

****

#### 概念模型的一种表示方法

****

  **实体——联系方法**

  概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。其中最为常用的是**实体——联系方法**(Entity-Relationship approach)。该方法用 `E-R` 图（E-R diagram）来描述现实世界的概念模型，`E-R` 方法也称为 `E-R` 模型。

****

### 1.2.3 数据模型的组成要素

****

  一般来讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件。因此数据模型具有以下三个要素：

* 数据结构。
* 数据操作。
* 数据的完整性约束条件。

****

#### 数据结构

****

  **数据结构描述数据库的组成对象以及对象之间的联系。**

  数据结构描述的内容有两类：

* 一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等；
* 一类是与数据之间联系有关的对象，如网状模型中的系型(set type)。

  数据结构是刻画一个数据模型性质最重要的方面，是所描述的对象类型的集合，**是对系统静态特性的描述**。

****

#### 数据操作

****

  **数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。**

  数据库主要有查询和更新（包括插入、删除、修改）两大类操作。

  数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言，**是对系统动态特性的描述**。

****

#### 数据的完整性约束条件

****

  **数据的完整性约束条件是一组完整性规则。**

  完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容，其规则包含：

* 实体完整性。
* 参照完整性。
* 用户定义完整性。

满足以上三者即满足了数据的完整性约束。

****

### 1.2.4 常用的数据模型

****

- 层次模型（Hierarchical Model）
- 网状模型（Network Model）
- 关系模型（Relational Model）
- 面向对象数据模型（Object Oriented Model）
- 对象关系模型（Object relational data Model）
- 半结构化数据模型（Semistructure data model）

其中层次模型和网状模型统称为格式化模型。

****

### 1.2.5 层次模型

****

  层次模型是数据库系统中最早出现的数据模型，层次数据库系统采用层次模型作为数据的组织方式。

****

#### 层次模型的数据结构

****

  在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：

* 有且只有一个结点没有双亲结点，这个结点称为根结点；
* 根以外的其他结点有且只有一个双亲结点。

 在层次模型中，**每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。**这就使得层次数据库系统只能处理一对多的实体联系。

  在层次模型中，同一双亲的子女结点称为兄弟结点（twin 或 sibling）没有子女结点的结点称为叶结点：

![](L:\02 学习笔记\数据库系统\图片1\层次模型.png)

由上图可以看出：**层次模型像一棵倒立的树，结点的双亲是唯一的**。

****

#### 层次模型的数据操纵与完整性约束

****

层次模型的数据操纵主要有查询、插入、删除和更新。操作时要满足层次模型的完整性约束条件：

* 进行插入操作时，如果没有相应的双亲结点值就不能插入它的子女结点值。
* 进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。
* 进行更新操作时，如果更新的结点有子节点，则应更新所有相应记录，以保证数据的一致性。

****

#### 层次模型优缺点

****

- 优点：
  1. 层次数据模型的数据结构简单清晰。
  2. 查询效率高，性能优于关系模型，不低于网状模型。
  3. 层次数据模型提供了良好的完整性支持。
- 缺点：
  1. 现实世界中很多联系是非层次的，如多对多联系。
  2. 如果一个结点有多个双亲结点等，用层次模型表示就不方便。
  3. 对插入和删除操作的限制比较多。
  4. 查询子女结点必须通过双亲结点。
  5. 由于结构严密，层次命令趋于程序化。

****

### 1.2.6 网状模型

****

  在现实世界中事物之间的联系更多的是非层次关系的，用层次模型表示非树形结构是很不直接的，网状模型则可以克服这一弊病。

****

#### 网状模型的数据结构

****

在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：

* 允许一个以上的结点无双亲。
* 一个结点可以有多于一个的双亲。

  网状模型是一种比层次模型更具普遍性的结构。**它去掉了层次模型的两个限制，允许多个结点没有双亲结点，允许结点有多个双亲结点；此外它还允许两个结点之间有多种联系（称之为复合联系）。**因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。

![](L:\02 学习笔记\数据库系统\图片1\网状模型.png)

由上图可知，层次模型中子女结点与双亲结点的联系是唯一的，而在网状模型中这种联系可以不唯一。

****

#### 网状模型的数据操纵与完整性约束

****

网状模型的数据操作与层次模型相同。

由于网状模型一般来说没有层次模型那样严格的完整性约束条件，因此具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。

****

#### 网状模型优缺点

****

- 优点：
  1. 能够更为直接地描述现实世界，如一个结点可以有多个双亲。
  2. 具有良好的性能，存取效率较高。
- 缺点：
  1. 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。
  2. `DDL`、`DML`语言复杂，用户不容易使用。
  3. 用户必须了解系统结构的细节，加重了编写应用程序的负担。

****

### 1.2.7 关系模型（重点）

****

  **关系模型是最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式。**

****

#### 关系模型的数据结构

****

- 关系模型建立在严格的数学基础上
- 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。
- 关系必须是规范化的，满足一定的规范条件，最基本的规范条件：**关系的每一个分量必须是一个不可分的数据项。**

借用下图，介绍关系模型的基本概念：

![](L:\02 学习笔记\数据库系统\图片1\关系模型.png)

* 关系（relation）：一个关系对应通常说的一张表。
  * 例如：图中的这张学生登记表。
* 元组（tuple）：表中的一行即为一个元组。
* 属性（attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
  * 例如：图所示的表有 `6` 列，对应 `6` 个属性（学号，姓名，年龄，性别，系名和年级）。
* 码（key）：也称为码键。表中的某个属性组，它可以唯一确定一个元组。
  * 例如：图中的学号可以唯一确定一个学生，也就成为本关系的码。
* 域（domain）：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。
  * 例如：如人的年龄一般在`1~120`岁之间，大学生年龄属性的域是（`15~45`岁)，性别的域是（男，女)，系名的域是一个学校所有系名的集合。
* 分量：元组中的一个属性值。
* 关系模式：对关系的描述，一般表示为关系名（属性1，属性2，…，属性n）。
  * 例如：上面的关系可描述为学生（学号，姓名，年龄，性别，系名，年级）。

  关系模型要求关系必须是**规范化**的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，**关系的每一个分量必须是一个不可分的数据项，**，不允许表中还有表。

****

#### 关系模型的数据操纵与完整性约束

****

数据操作包含查询、插入、删除、更新。操作时要满足关系模型的完整性约束条件：

- 数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合。
- 存取路径对用户隐蔽，用户只要指出“干什么”或者“找什么”，不必详细说明“怎么干”或者“怎么找”。
- 保证操作遵循实体完整性、参照完整性、用户定义的完整性原则。

****

#### 关系模型的优缺点

****

- 优点：
  1. 建立在严格的数学概念的基础上。
  2. 概念单一，数据结构简单、清晰，用户易懂易用，实体和各类联系都用关系来表示，对数据的检索和更新的结果也是关系。
  3. 关系模型的存取路径对用户透明，具有更高的数据独立性，更好的安全保密性，简化了程序员的工作和数据库开发建立的工作。
- 缺点：
  1. 存取路径对用户透明导致查询效率往往不如非关系数据模型。
  2. 为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度。

****

## 1.3 数据库系统的结构

****

- 从数据库管理系统角度看，是三级模式结构。
- 从数据库最终用户角度看，单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器。

****

### 1.3.1 数据库系统模式的概念

****

- 型（Type）：对某一类数据结构和属性的说明。
- 值（Value）：型的一个具体赋值。
- 模式（Schema）：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，反映的是数据的结构及其联系，模式是**相对稳定的**。
- 实例（Instance）：模式的一个具体值，反映数据库某一时刻的状态，同一个模式可以有很多实例，实例**随数据库中的数据的更新而变动**。

****

### 1.3.2 数据库系统的三级模式结构

****

  数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成：

![](L:\02 学习笔记\数据库系统\图片1\三级结构.png)

****

#### 模式（schema）

****

  模式也称逻辑模式，其特点如下：

- 据库中全体数据的逻辑结构和特征的描述，所有用户的公共数据视图，综合了所有用户的需求，是**数据库系统模式结构的中间层（地位）**，一个数据库只有一个模式。
- 模式是数据库数据在逻辑级上的视图，以某种数据模型为基础。
- 内容：数据的逻辑结构（如数据项的名字、类型、取值范围等），数据之间的联系；数据有关的安全性、完整性要求。
- 数据库管理系统提供模式数据定义语言（模式`DDL`）来严格地定义模式。

****

#### 外模式（external schema）

****

外模式也称子模式（subschema）或用户模式：

- 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，数据库用户的数据视图，是与某一应用有关的数据的逻辑表示， **介于模式与应用之间**（地位）。
- 模式与外模式的关系：一对多，外模式通常是模式的子集，一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求，对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。
- 外模式与应用的关系：一对多，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。

****

#### 内模式（internal schema）

****

内模式也称存储模式（storage schema）：

- 是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。
- 内容：记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储），索引的组织方式，数据是否压缩存储，数据是否加密，数据存储记录结构的规定。
- 一个数据库只有一个内模式。

****

### 1.3.3 数据库的二级映像功能与数据独立性

****

#### 外模式/模式映像

****

- 内容：定义外模式与模式之间的对应关系，每一个外模式都对应一个外模式／模式映象，映象定义通常包含在各自外模式的描述中。

- 用途：

  * 保证数据的逻辑独立性

  * 当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变应用程序是依据数据的外模式编写的；
  * 由此保证应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。

****

#### 模式/内模式映像

****

- 内容：模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。数据库中模式／内模式映象是唯一的，该映象定义通常包含在模式描述中。
- 用途：
  * 保证数据的物理独立性。
  * 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变应用程序不受影响。
  * 由此保证了数据与程序的物理独立性，简称数据的物理独立性。

****

# 2. 关系数据库

****

  提出关系模型的是美国 `IBM` 公司的 `E.F.Codd`：

* 1970年提出关系数据模型，之后，提出了关系代数和关系演算的概念。
* 1972年提出了关系的第一、第二、第三范式。
* 1974年提出了关系的 `BC` 范式。

****

## 2.1 关系数据结构及形式化定义

****

  按照数据模型的三个要素：

* 关系模型由关系数据结构；
* 关系操作集合；
* 关系完整性约束三部分组成。

下面将对这三部分内容进行分别介绍。

****

### 2.1.1 关系

****

  关系模型的数据结构非常简单，只包含单一的数据结构—关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。

****

#### 域

****

* 是一组具有相同数据类型的值的集合。
* 例如：自然数、整数、实数的集合。

****

#### 笛卡尔积

****

* 给定一组域：$D_1, D_2, D_3, \dots, D_n$，且允许其中某些域是相同的
* 则其笛卡尔积为：$D_1 \times D_2 \times D_n \times \dots \times D_n = \{ (d_1, d_2, d_3 \dots, d_n)\ | \ d_i \in D_i, i = 1, 2, \dots , n \}$。
* 其中每一个元素 $(d_1, d_2, d_3 \dots, d_n)$ 叫做一个 $n$ 元组，或简称元组，其中 $d_i$ 为分量。

一个域允许的不同取值个数称为这个域的**基数**：

* 若 $D_i (i = 1, 2, \dots, n)$ 为有限集，其基数为 $m_i(i = 1, 2, \dots, n)$
* 则 $D_1 \times D_2 \times D_n \times \dots \times D_n$ 的基数 $M = \prod^{n}_{i = 1}m_i$。

笛卡尔积可以表示为一张二维表，表中的每行对应一个元组，表中的每一列的值来自一个域。

例如：

* 已知：$D_1 = X = \{ a, b \}, D_2 = Y = \{ c, d \}$

* 则 $D_1 \times D_2$ 的笛卡尔积为 $D_1 \times D_2 = \{ (a, c), (a, d), (b, c), (b, d) \}$

* 笛卡尔基数为 $2 \times 2 = 4$，共 $4$ 个元组，可生成表格如下：

* | $X$  | $Y$  |
  | :--: | :--: |
  | $a$  | $c$  |
  | $a$  | $d$  |
  | $b$  | $c$  |
  | $b$  | $d$  |

****

#### 关系

****

* $D_1 \times D_2 \times D_n \times \dots \times D_n$ 的子集叫做在域 $D_1, D_2, D_3, \dots, D_n$ 上的关系。
* 表示为 $R(D_1, D_2, D_3, \dots, D_n)$，其中 $R$ 为关系名，$n$ 为关系的目或度（Degree）。
* 关系中的每个元素是关系中的元组，通常用 $t$ 表示。
* 当 $n = 1$ 时，称该关系为单元关系（Unary relation）或一元关系，$n = 2$ 时称为二元关系（Binary relation）。

  **关系是笛卡儿积的有限子集**，所以**关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域**。

****

#### 码

****

* 候选码（Candidate key）：若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（如学号，身份证号）。
* 全码（All key）：在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码。
* 主码（Primary key）：若一个关系有多个候选码，则选定其中一个为主码。候选码的诸属性称为主属性（Prime attribute）。不包含在任何侯选码中的属性称为非码属性或非主属性（Non-key attribute）。

  **主码和候选码本质相同，只是数量不同**。

****

#### 三类关系

****

* 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示。
* 查询表：查询结果对应的表。
* 视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。

****

#### 基本关系的性质

****

* 列同质的（Homogeneous）每一列中的分量是同一类型的数据，来自同一个域。
* 不同的列可出自同一个域：
  * 其中的每一列称为一个属性。
  * 不同的属性要给予不同的属性名。
* 列的顺序无所谓(属性名打破有序性）。
* 任意两个元组不能完全相同（候选码不同）。
* 行的顺序无所谓，即行的次序可以任意交换。
* 分量必须取原子值，每一个分量都必须是不可分的数据项。这是规范条件中最基本的。

****

### 2.1.2 关系模式

****

  在数据库中要区分型和值，关系数据库中：

* 关系模式（Relation Schema）是型，关系是值。

关系模式是对关系的描述：

* 元组集合的结构：
  * 属性构成
  * 属性来自的域
  * 属性与域之间的映象关系
* 完整性约束条件，元组语义。

  **关系的描述称为关系模式**（relation schema）。它可以形式化地表示为 $R(U, D, DOM, F)$：

* $R$ 为关系名
* $U$ 为组成该关系的属性名集合
* $D$ 为 $U$ 中属性所来自的域
* $DOM$ 为属性向域的映像集合
* $F$ 为属性间数据的依赖关系集合。

****

### 2.1.3 关系数据库

****

  在关系模型中，实体以及实体间的联系都是用关系来表示的。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。

  关系数据库也有型和值之分：

* 关系数据库的型也称为关系数据库模式，是对关系数据库的描述。
* 关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。
* 关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。

****

### 2.1.4 关系模型的存储结构

****

- 有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成。
- 有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

****

## 2.2 关系操作

****

### 2.2.1 基本的关系操作

****

- 查询：
  * 基本操作：选择、投影、并、差、笛卡尔积；
  * 其他操作：连接、除、交，可由上述基本操作导出。
- 数据更新：插入、删除、修改。

关系操作的特点是集合操作方式：

* 操作的对象和结果都是集合。
* 这种操作方式也称为一次一集合(set-at-a-time)的方式。

相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

****

### 2.2.2 关系数据语言的分类

****

![](L:\02 学习笔记\数据库系统\图片2\操作语言.png)

**特点**：

- 关系语言是一种高度非过程化的语言，存取路径的选择由 `DBMS` 的优化机制来完成，用户不必用循环结构就可以完成数据操作。
- 能够嵌入高级语言中使用。
- 关系代数、元组关系演算和域关系演算三种语言在表达能力上完全等价。

****

## 2.3 关系的完整性

****

  关系模型中有三类完整性约束：

* 实体完整性(entity integrity)
* 参照完整性(referential integrity)
* 用户定义的完整性(user-defined integrity)。

  **关系模型必须满足实体完整性和参照完整性**，被称作是关系的两个**不变性**，应该由关系系统自动支持。

  用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。

****

### 2.3.1 实体完整性

****

* 若属性（指一个或一组属性）$A$ 是基本关系 $R$ 的主属性，则 $A$ 不能取空值（null value）。
* 所谓空值就是“不知道”或“不存在”或“无意义”的值。

**原因**：

1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性。

****

### 2.3.2 参照完整性

****

**外码**：  

* 设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码，
* 如果 $F$ 与基本关系 $S$ 的主码 $K_s$ 相对应，则称 $F$ 是 $R$ 的外码。
* 基本关系 $R$ 称为参照关系（Referencing  Relation）
* 基本关系 $S$ 称为被参照关系（Referenced Relation）或目标关系（Target Relation）

关系 $R$ 和 $S$ 不一定是不同的关系，目标关系 $S$ 的主码 $K_s$ 和参照关系的外码 $F$ 必须定义在同一个（或一组）域上。

外码并不一定要与相应的主码同名；当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别。

**参照完整性规则**：

* 若属性（或属性组）$F$ 是基本关系 $R$ 的外码，它与基本关系 $S$ 的主码 $K$ 相对应（基本关系 $R$ 和 $S$ 不一定是不同的关系）
* 则对于 $R$ 中每个元组在 $F$ 上的值必须：
  * 取空值（$F$ 的每个属性值均为空值）
  * 或等于 $S$ 中某个元组的主码值

****

### 2.3.3 用户定义的完整性

****

- 用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。

****

## 2.4 关系代数

****

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。

运算具备以下要偶素：

* 运算对象
* 运算符
* 运算结果

**任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果**。

关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括两类：

* 集合运算符
* 专门的关系运算符

![](L:\02 学习笔记\数据库系统\图片2\运算符.png)

****

### 2.4.1 传统的集合运算

****

传统的集合运算是二目运算，包括并、差、交、笛卡儿积4种运算。

设关系 $R$ 和关系 $S$ 具有相同的目（即两个关系都有 $n$ 个属性），且相应的属性取自同一个域，$t$ 是元组变量，$t \in R$ 表示 $t$ 是 $R$ 的一个元组。可以定义并、差、交、笛卡儿积运算如下：

* 并（union）：
  * 关系 $R$ 与关系 $S$ 的并记作： $R \cup S = \{t |t \in R \land t \in S \}$
  * 其结果仍为 $n$ 目关系，由属于 $R$ 或属于 $S$ 的元组组成。
* 差（except）：
  * 关系 $R$ 与关系 $S$ 的差记作：$R - S = \{ t | t \in R \land t \notin S \}$
  * 其结果关系仍为 $n$ 目关系，由属于 $R$ 而不属于 $S$ 的所有元组组成。
* 交（intersection）：
  * 关系 $R$ 与关系 $S$ 的交记作 $R \cap S = \{ t | t \in R \land t \in S \}$ 
  * 其结果关系仍为 $n$ 目关系，由既属于 $R$ 又属于 $S$ 的元组组成。
  * 关系的交可以用差来表示，即 $R \cap S = R - ( R - S )$ 。
* 笛卡儿积（cartesian product）：
  * 这里笛卡儿积的元素是元组。
  * 两个分别为 $n$ 目和 $m$ 目的关系 $R$ 和 $S$ 的笛卡儿积是一个 $(n + m)$ 列的元组的集合。元组的前 $n$ 列是关系 $R$ 的一个元组，后 $m$ 列是关系 $S$ 的一个元组。
  * 若 $R$ 有个元组，$S$ 有 $2$ 个元组，则关系 $R$ 和关系 $S$ 的笛卡儿积有 $k_1 \times k_2$ 个元组。记作 $R \times S = \{\overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \}$

![](L:\02 学习笔记\数据库系统\图片2\传统集合运算.png)

****

### 2.4.2 专门的关系运算

****

专门的关系运算包括选择、投影、连接、除运算等。为了叙述上的方便，先引入几个记号：

* $R$，$t \in R$，$t[A_i]$
  * 设关系模式为 $R(A_1, A_2, \dots , A_n)$
  * 它的一个关系设为 $R$
  * $t \in R$ 表示 $t$ 是 $R$ 的一个元组
  * $t[A_i]$ 表示元组 $t$ 中相应于属性 $A_i$ 的一个分量
* $A$，$t[A]$，$\overline{A}$
  * 若 $A = \{ A_{i1}, A_{i2}, \dots , A_{ik} \}$，其中 $A_{i1}, A_{i2}, \dots , A_{ik}$ 是 $A_1, A_2, \dots , A_n$ 中的一部分，则 $A$ 被称为属性列或属性组。
  * $t[A] = (t[A_{i1}], t[A_{i2}], \dots , t[A_{ik}])$ 表示元组 $t$ 在属性列$A$ 上诸分量的集合。
  * $\overline{A}$ 则表示 $\{ A_1, A_2, \dots , A_n \}$ 中去掉 $A_{i1}, A_{i2}, \dots , A_{ik}$ 后剩余的属性组。
* $\overset{\frown}{t_r t_s}$
  * $R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系
  * $t_r \in R$，$t_s \in S$， $\overset{\frown}{t_r t_s}$ 称为元组的连接
  * $\overset{\frown}{t_r t_s}$ 是一个 $n + m$ 列的元组，前 $n$ 个分量为 $R$ 中的一个 $n$ 元组，后 $m$ 个分量为 $S$ 中的一个 $m$ 元组
* 象集 $Z_x$
  * 给定一个关系 $R(X, Z)$， $X$ 和 $Z$ 为属性组
  * 当 $t[X] = x$ 时，$x$ 在 $R$ 中的象集（Images Set） 为：$Z_x = \{ t[Z] | t\in R, t[X] = x \}$
  * 它表示 $R$ 中属性组 $X$ 上值为 $x$ 的诸元组在 $Z$ 上分量的集合。

****

#### 选择

****

* 选择又称为限制（Restriction）
* 选择运算符的含义：
  * 在关系R中选择满足给定条件的诸元组
  * $\sigma_F(R) = \{ t | t \in R \land F(t) = `true' \}$
  * $F$：选择条件，是一个逻辑表达式，取值为“真”或“假”
  * 基本形式为：$X_1 \theta Y_1$
  * $\theta$ 表示比较运算符，它可以是 $\gt, \ge, \lt, \le, =, \ne$。
  * $X_1, Y_1$ 等是属性名、常量、简单函数；属性名也可以用它的序号来代替；
  * 在基本的选择条件上可以进一步进行逻辑运算，求非 ，与，或运算。

![](L:\02 学习笔记\数据库系统\图片2\选择.png)

****

#### 投影

****

* 从 $R$ 中选择出若干属性列组成新的关系
* $\Pi_A(R) = \{ t[A] | t \in R \}$
* $A$ ：$R$ 中的属性
* 投影操作主要是从列的角度进行运算
* 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

![](L:\02 学习笔记\数据库系统\图片2\投影.png)

****

#### 连接

****

* 连接也称为 $\theta$ 连接
* 连接运算的含义：
  * 从两个关系的笛卡尔积中选取属性间满足一定条件的元组
  * $R \underset{A \theta B}{\bowtie} S = \{ \overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land t_r[A] \theta t_s[B] \}$
  * $A$ 和 $B$ ：分别为 $R$ 和 $S$ 上度数相等且可比的属性组
* 连接运算从 $R$ 和 $S$ 的广义笛卡尔积 $R \times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $\theta$ 的元组 

两类常用连接运算：

* 等值连接（equijoin）：
  * $\theta$ 为 $=$ 的运算
  * 从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A,B$ 属性值相等的那些元组
  * $R \underset{A = B}{\bowtie} S = \{ \overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land t_r[A] \theta t_s[B] \}$
* 自然连接（natural join）：
  * 自然连接是一种特殊的等值连接：
    * 两个关系中进行比较的分量必须是相同的属性组
    * 在结果中把重复的属性列去掉
  * 自然连接的含义：
    * $R$ 和 $S$ 具有相同的属性组 $B$
    * $R \bowtie S = \{ \overset{\frown}{t_r t_s} [U-B] | t_r \in R \land t_s \in S \land t_r[B] = t_s[B] \}$

一般的连接操作是从行的角度进行运算。

![](L:\02 学习笔记\数据库系统\图片2\连接.png)

​    **自然连接还需要取消重复列，所以是同时从行和列的角度进行运算**。 

****

#### 除运算

****

* 给定关系 $R(X, Y)$ 和 $S(Y, Z)$，其中 $X, Y, Z$ 为属性组。
* $R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须出自相同的域集。
* $R$ 与 $S$ 的除运算得到一个新的关系 $P(X)$
* $P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：
  * 元组在 $X$ 上分量值 $x$ 的象集 $Y_x$ 包含 $S$ 在 $Y$ 上投影的集合
  * $R \div S = \{ t_r[X] | t_r \in R \land \Pi_Y(S) \subseteq Y_x \}$
  * $Y_x$ ：$x$ 在 $R$ 中的象集，$x = t_r[X]$

**除操作是同时从行和列角度进行运算**

![](L:\02 学习笔记\数据库系统\图片2\除.png)

****

# 3. SQL 与 MySQL

****

## 3.1 SQL

****

### 3.1.1 SQL 简介

****

* `SQL`（**Structured Query Language：结构化查询语言**）用于管理关系数据库管理系统（`RDBMS`）。
* `SQL` 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。
* 这类数据库包括：`MySQL`、`SQL Server`、`Access`、`Oracle`、`Sybase`、`DB2` 等。
* `SQL` 在 `1986` 年成为 `ANSI`（American National Standards Institute 美国国家标准化组织）的一项标准，在 `1987` 年成为国际标准化组织（ISO）标准。

****

### 3.1.2 基础语法

****

#### 基本约定

****

**SQL大小写不敏感**：

* `SQL` 对大小写不敏感：故 `SELECT` 与 `select` 是相同的，但仍建议将 `SQL` 命令语句纯大写字母书写，有如下优点：
  * 提高可读性：在 `SQL` 命令语句中使用纯大写可以使关键字、函数、表名等部分更加醒目，容易阅读和理解。
  * 统一规范：使用纯大写可以统一 `SQL` 命令语句的书写规范，方便代码的维护和修改。
  * 避免歧义：在 `SQL` 命令语句中使用纯大写可以避免大小写混用导致的语法错误和歧义。
* 虽然 `SQL` 对大小写不敏感，但是在 `SQL` 命令语句中使用纯大写仍然是一个良好的习惯和最佳实践。

 **SQL语句的分号和逗号**：

* 某些数据库系统要求在每条 `SQL` 语句的末端使用分号。
* 分号是在数据库系统中分隔每条 `SQL` 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 `SQL` 语句。
* 逗号通常用来分隔列名或表达式、值或子查询等元素。
* 至于某些长语句使用逗号，在不同的数据库系统中有不同的分隔规则。

****

#### 基础命令

****

- **SELECT**：从数据库中提取数据
- **UPDATE**：更新数据库中的数据
- **DELETE**：从数据库中删除数据
- **INSERT INTO**：向数据库中插入新数据
- **CREATE DATABASE**：创建新数据库
- **ALTER DATABASE**：修改数据库
- **CREATE TABLE**：创建新表
- **ALTER TABLE**：变更（改变）数据库表
- **DROP TABLE**：删除表
- **CREATE INDEX**：创建索引（搜索键）
- **DROP INDEX**：删除索引

****

## 3.2 MySQL

****

### 3.2.1 MySQL 简介

****

* `MySQL` 为关系型数据库系统（Relational Database Management System）
* `MySQL` 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
* `MySQL` 使用标准的 `SQL` 数据语言形式。
* `MySQL` 可以运行于多个系统上，并且支持多种语言。

****

### 3.2.2 基本语法

****

#### 数据类型

****

##### 数值类型

****

`MySQL` 支持所有标准 `SQL` 数值数据类型：

* 包括严格数值数据类型(`INTEGER`、`SMALLINT`、`DECIMAL` 和 `NUMERIC`)
* 近似数值数据类型(`FLOAT`、`REAL` 和 `DOUBLE PRECISION`)。

**注意**：`INT` 是 `INTEGER` 的同义词，关键字 `DEC` 是 `DECIMAL` 的同义词。

| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

****

##### 日期和时间类型

****

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'               | YYYY-MM-DD hh:mm:ss | 混合日期和时间值         |
| TIMESTAMP | 4             | '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYY-MM-DD hh:mm:ss | 混合日期和时间值，时间戳 |











****

# 4. 别急

****

































****

# 5. 别急

****































****

# 6. 别急

****





































****

# 7. 别急

****



































