# 1. 绪论

****

## 1.1 数据库系统概述

****

### 1.1.1 基本概念

****

#### 数据（data）

* 数据是数据库中存储的基本对象。
* 描述事物的符号记录称为数据。
* 数据有多种表现形式，它们都可以经过数字化之后存入计算机。


数据的表现形式还不能完全表达其内容，需要经过解释，数据和关于数据的解释是不可分的。

数据的解释是指对数据含义的说明，数据的含义称为**数据的语义**，数据与其语义是不可分的。

****

#### 数据库（DataBase, DB）

* 数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。
* 数据库中的数据按一定的数据模型组织、描述和储存，具有以下特点：
  * 较小的冗余度（redundancy）
  * 较高的数据独立性（data independency）
  * 易扩展性（scalability）
  * 可为各种用户共享

  概括地讲，数据库数据具有永久存储、有组织和可共享三个基本特点。

****

#### 数据库管理系统（DataBase Management System, DBMS）

  数据库管理系统是位于用户与操作系统之间的一层**数据管理软件**。**数据库管理系统和操作系统一样是计算机的基础软件**，也是一个大型复杂的软件系统。它的主要功能包括以下几个方面：

* 数据定义功能：
  * 提供数据定义语言（Data Definition Language, DDL）可对数据库中的数据对象的组成与结构进行定义。
* 数据组织、存储和管理：
  * 数据库管理系统要分类组织、存储和管理各种数据；
  * 提高存储空间利用率和方便存取，提供多种存取方法来提高存取效率。
* 数据操纵功能：
  * 提供数据操纵语言（Data Manipulation Language, DML）可操纵数据，实现对数据库的增删改查等。
* 数据库的事务管理和运行管理：
  * 数据库在建立、运用和维护时由数据库管理系统统一管理和控制；
  * 保证事务的正确运行，保证数据的安全性、完整性、多用户对数据的并发使用及发生故障后的系统恢复。
* 数据库的建立和维护功能：
  * 包括数据库初始数据的输入、转换功能，数据库的转储、恢复功能，数据库的重组织功能和性能监视、分析功能等。
* 其他功能：
  * 包括数据库管理系统与网络中其他软件系统的通信功能；
  * 一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能；
  * 异构数据库之间的互访和互操作功能等。

****

#### 数据库系统（DataBase System, DBS）

* 由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator，DBA）组成的存储、管理、处理和维护数据的系统。
* 数据库的建立、使用和维护等工作只靠一个数据库管理系统远远不够，还要有专门的人员来完成，这些人被称为数据库管理员。

![](L:\02 学习笔记\数据库系统\图片1\概念.png)

****

### 1.1.2 数据管理技术的产生和发展

****

![](L:\02 学习笔记\数据库系统\图片1\阶段发展.png)

****

### 1.1.3 数据库系统的特点

****

* 数据结构化：
  *  **数据库系统实现整体数据的结构化，是数据库系统与文件系统的本质区别。**
  * 所谓“整体”结构化，不仅数据内部是结构化的，而且数据整体是结构化的，数据之间是具有联系的。
* 数据的共享性高、冗余度低且易扩充：
  * 数据可以被多个用户、多个应用共享使用，数据共享可以大大减少数据冗余，节约存储空间。
  * 避免数据之间的不相容性与不一致性。
* 数据独立性高：
  * 物理独立性：用户的应用程序与数据库中数据的物理存储是相互独立的。
  * 逻辑独立性：用户的应用程序与数据库的逻辑结构是相互独立的。
* 数据由数据库管理系统统一管理和控制：
  * 保证数据的安全性（security），数据的完整性（integrity），支持并发（concurrency）和数据库恢复（recovery）。

  **总结**：数据库是长期存储在计算机内有组织、大量、共享的数据集合。它可以供各种用户共享，具有最小冗余度和较高的数据独立性。数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性和安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。

****

## 1.2  数据模型

****

### 1.2.1 两种数据模型

****

  数据模型（data model）也是一种模型，它是对现实世界数据特征的抽象，**数据模型是数据库系统的核心和基础。**

  数据模型应满足三方面要求：

* 能比较真实地模拟现实世界。
* 容易为人所理解。
* 便于在计算机上实现。

****

#### 概念模型

****

  第一类概念模型（conceptual model），也称信息模型，它是按用户的观点来对数据和信息建模，使用简单的符号来描述信息，没有严格的规定，只要能清晰反映现实世界的信息就行，主要用于数据库设计。

****

#### 逻辑模型

****

  第二类中的逻辑模型主要包括层次模型（hierarchical model）、网状模型（network model）、关系模型（relational model）、面向对象数据模型（object oriented data model）和对象关系数据模型（object relational data model）、半结构化数据模型（semistructured data model）等。它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。

  第二类中的物理模型是对数据最底层的抽象，它描述数据在系统内部的表示方式和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。物理模型的具体实现是数据库管理系统的任务。

![](L:\02 学习笔记\数据库系统\图片1\抽象.png)

****

### 1.2.2 概念模型

****

#### 基本概念

****

- 实体（Entity）：客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。
- 属性（Attribute）：实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。
- 码（Key）：唯一标识实体的属性集称为码。
- 实体型（Entity Type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。
  * 例如：学生（学号，姓名，性别，出生年月，所在院系，入学时间）
- 实体集（Entity Set）：同型实体的集合称为实体集.
  * 例如：2021级计算机学院的全体学生。
- 联系（Relationship）：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。

****

#### 概念模型的一种表示方法

****

  **实体——联系方法**

  概念模型是对信息世界建模，所以概念模型应该能够方便、准确地表示出上述信息世界中的常用概念。其中最为常用的是**实体——联系方法**(Entity-Relationship approach)。该方法用 `E-R` 图（E-R diagram）来描述现实世界的概念模型，`E-R` 方法也称为 `E-R` 模型。

****

### 1.2.3 数据模型的组成要素

****

  一般来讲，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特性、动态特性和完整性约束条件。因此数据模型具有以下三个要素：

* 数据结构。
* 数据操作。
* 数据的完整性约束条件。

****

#### 数据结构

****

  **数据结构描述数据库的组成对象以及对象之间的联系。**

  数据结构描述的内容有两类：

* 一类是与对象的类型、内容、性质有关的，如网状模型中的数据项、记录，关系模型中的域、属性、关系等；
* 一类是与数据之间联系有关的对象，如网状模型中的系型(set type)。

  数据结构是刻画一个数据模型性质最重要的方面，是所描述的对象类型的集合，**是对系统静态特性的描述**。

****

#### 数据操作

****

  **数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。**

  数据库主要有查询和更新（包括插入、删除、修改）两大类操作。

  数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言，**是对系统动态特性的描述**。

****

#### 数据的完整性约束条件

****

  **数据的完整性约束条件是一组完整性规则。**

  完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容，其规则包含：

* 实体完整性。
* 参照完整性。
* 用户定义完整性。

满足以上三者即满足了数据的完整性约束。

****

### 1.2.4 常用的数据模型

****

- 层次模型（Hierarchical Model）
- 网状模型（Network Model）
- 关系模型（Relational Model）
- 面向对象数据模型（Object Oriented Model）
- 对象关系模型（Object relational data Model）
- 半结构化数据模型（Semistructure data model）

其中层次模型和网状模型统称为格式化模型。

****

### 1.2.5 层次模型

****

  层次模型是数据库系统中最早出现的数据模型，层次数据库系统采用层次模型作为数据的组织方式。

****

#### 层次模型的数据结构

****

  在数据库中定义满足下面两个条件的基本层次联系的集合为层次模型：

* 有且只有一个结点没有双亲结点，这个结点称为根结点；
* 根以外的其他结点有且只有一个双亲结点。

 在层次模型中，**每个结点表示一个记录类型，记录类型之间的联系用结点之间的连线（有向边）表示，这种联系是父子之间的一对多的联系。**这就使得层次数据库系统只能处理一对多的实体联系。

  在层次模型中，同一双亲的子女结点称为兄弟结点（twin 或 sibling）没有子女结点的结点称为叶结点：

![](L:\02 学习笔记\数据库系统\图片1\层次模型.png)

由上图可以看出：**层次模型像一棵倒立的树，结点的双亲是唯一的**。

****

#### 层次模型的数据操纵与完整性约束

****

层次模型的数据操纵主要有查询、插入、删除和更新。操作时要满足层次模型的完整性约束条件：

* 进行插入操作时，如果没有相应的双亲结点值就不能插入它的子女结点值。
* 进行删除操作时，如果删除双亲结点值，则相应的子女结点值也将被同时删除。
* 进行更新操作时，如果更新的结点有子节点，则应更新所有相应记录，以保证数据的一致性。

****

#### 层次模型优缺点

****

- 优点：
  1. 层次数据模型的数据结构简单清晰。
  2. 查询效率高，性能优于关系模型，不低于网状模型。
  3. 层次数据模型提供了良好的完整性支持。
- 缺点：
  1. 现实世界中很多联系是非层次的，如多对多联系。
  2. 如果一个结点有多个双亲结点等，用层次模型表示就不方便。
  3. 对插入和删除操作的限制比较多。
  4. 查询子女结点必须通过双亲结点。
  5. 由于结构严密，层次命令趋于程序化。

****

### 1.2.6 网状模型

****

  在现实世界中事物之间的联系更多的是非层次关系的，用层次模型表示非树形结构是很不直接的，网状模型则可以克服这一弊病。

****

#### 网状模型的数据结构

****

在数据库中，把满足以下两个条件的基本层次联系集合称为网状模型：

* 允许一个以上的结点无双亲。
* 一个结点可以有多于一个的双亲。

  网状模型是一种比层次模型更具普遍性的结构。**它去掉了层次模型的两个限制，允许多个结点没有双亲结点，允许结点有多个双亲结点；此外它还允许两个结点之间有多种联系（称之为复合联系）。**因此，网状模型可以更直接地去描述现实世界。而层次模型实际上是网状模型的一个特例。

![](L:\02 学习笔记\数据库系统\图片1\网状模型.png)

由上图可知，层次模型中子女结点与双亲结点的联系是唯一的，而在网状模型中这种联系可以不唯一。

****

#### 网状模型的数据操纵与完整性约束

****

网状模型的数据操作与层次模型相同。

由于网状模型一般来说没有层次模型那样严格的完整性约束条件，因此具体的网状数据库系统对数据操纵都加了一些限制，提供了一定的完整性约束。

****

#### 网状模型优缺点

****

- 优点：
  1. 能够更为直接地描述现实世界，如一个结点可以有多个双亲。
  2. 具有良好的性能，存取效率较高。
- 缺点：
  1. 结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。
  2. `DDL`、`DML`语言复杂，用户不容易使用。
  3. 用户必须了解系统结构的细节，加重了编写应用程序的负担。

****

### 1.2.7 关系模型（重点）

****

  **关系模型是最重要的一种数据模型。关系数据库系统采用关系模型作为数据的组织方式。**

****

#### 关系模型的数据结构

****

- 关系模型建立在严格的数学基础上
- 在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。
- 关系必须是规范化的，满足一定的规范条件，最基本的规范条件：**关系的每一个分量必须是一个不可分的数据项。**

借用下图，介绍关系模型的基本概念：

![](L:\02 学习笔记\数据库系统\图片1\关系模型.png)

* 关系（relation）：一个关系对应通常说的一张表。
  * 例如：图中的这张学生登记表。
* 元组（tuple）：表中的一行即为一个元组。
* 属性（attribute）：表中的一列即为一个属性，给每一个属性起一个名称即属性名。
  * 例如：图所示的表有 `6` 列，对应 `6` 个属性（学号，姓名，年龄，性别，系名和年级）。
* 码（key）：也称为码键。表中的某个属性组，它可以唯一确定一个元组。
  * 例如：图中的学号可以唯一确定一个学生，也就成为本关系的码。
* 域（domain）：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。
  * 例如：如人的年龄一般在`1~120`岁之间，大学生年龄属性的域是（`15~45`岁)，性别的域是（男，女)，系名的域是一个学校所有系名的集合。
* 分量：元组中的一个属性值。
* 关系模式：对关系的描述，一般表示为关系名（属性1，属性2，…，属性n）。
  * 例如：上面的关系可描述为学生（学号，姓名，年龄，性别，系名，年级）。

  关系模型要求关系必须是**规范化**的，即要求关系必须满足一定的规范条件，这些规范条件中最基本的一条就是，**关系的每一个分量必须是一个不可分的数据项，**，不允许表中还有表。

****

#### 关系模型的数据操纵与完整性约束

****

数据操作包含查询、插入、删除、更新。操作时要满足关系模型的完整性约束条件：

- 数据操作是集合操作，操作对象和操作结果都是关系，即若干元组的集合。
- 存取路径对用户隐蔽，用户只要指出“干什么”或者“找什么”，不必详细说明“怎么干”或者“怎么找”。
- 保证操作遵循实体完整性、参照完整性、用户定义的完整性原则。

****

#### 关系模型的优缺点

****

- 优点：
  1. 建立在严格的数学概念的基础上。
  2. 概念单一，数据结构简单、清晰，用户易懂易用，实体和各类联系都用关系来表示，对数据的检索和更新的结果也是关系。
  3. 关系模型的存取路径对用户透明，具有更高的数据独立性，更好的安全保密性，简化了程序员的工作和数据库开发建立的工作。
- 缺点：
  1. 存取路径对用户透明导致查询效率往往不如非关系数据模型。
  2. 为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度。

****

## 1.3 数据库系统的结构

****

- 从数据库管理系统角度看，是三级模式结构。
- 从数据库最终用户角度看，单用户结构、主从式结构、分布式结构、客户/服务器、浏览器/应用服务器/数据库服务器。

****

### 1.3.1 数据库系统模式的概念

****

- 型（Type）：对某一类数据结构和属性的说明。
- 值（Value）：型的一个具体赋值。
- 模式（Schema）：数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，反映的是数据的结构及其联系，模式是**相对稳定的**。
- 实例（Instance）：模式的一个具体值，反映数据库某一时刻的状态，同一个模式可以有很多实例，实例**随数据库中的数据的更新而变动**。

****

### 1.3.2 数据库系统的三级模式结构

****

  数据库系统的三级模式结构是指数据库系统是由外模式、模式和内模式三级构成：

![](L:\02 学习笔记\数据库系统\图片1\三级结构.png)

****

#### 模式（schema）

****

  模式也称逻辑模式，其特点如下：

- 据库中全体数据的逻辑结构和特征的描述，所有用户的公共数据视图，综合了所有用户的需求，是**数据库系统模式结构的中间层（地位）**，一个数据库只有一个模式。
- 模式是数据库数据在逻辑级上的视图，以某种数据模型为基础。
- 内容：数据的逻辑结构（如数据项的名字、类型、取值范围等），数据之间的联系；数据有关的安全性、完整性要求。
- 数据库管理系统提供模式数据定义语言（模式`DDL`）来严格地定义模式。

****

#### 外模式（external schema）

****

外模式也称子模式（subschema）或用户模式：

- 数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述，数据库用户的数据视图，是与某一应用有关的数据的逻辑表示， **介于模式与应用之间**（地位）。
- 模式与外模式的关系：一对多，外模式通常是模式的子集，一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求，对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同。
- 外模式与应用的关系：一对多，同一外模式也可以为某一用户的多个应用系统所使用，但一个应用程序只能使用一个外模式。

****

#### 内模式（internal schema）

****

内模式也称存储模式（storage schema）：

- 是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。
- 内容：记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储），索引的组织方式，数据是否压缩存储，数据是否加密，数据存储记录结构的规定。
- 一个数据库只有一个内模式。

****

### 1.3.3 数据库的二级映像功能与数据独立性

****

#### 外模式/模式映像

****

- 内容：定义外模式与模式之间的对应关系，每一个外模式都对应一个外模式／模式映象，映象定义通常包含在各自外模式的描述中。

- 用途：

  * 保证数据的逻辑独立性

  * 当模式改变时，数据库管理员修改有关的外模式／模式映象，使外模式保持不变应用程序是依据数据的外模式编写的；
  * 由此保证应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。

****

#### 模式/内模式映像

****

- 内容：模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。数据库中模式／内模式映象是唯一的，该映象定义通常包含在模式描述中。
- 用途：
  * 保证数据的物理独立性。
  * 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变应用程序不受影响。
  * 由此保证了数据与程序的物理独立性，简称数据的物理独立性。

****

# 2. 关系数据库

****

  提出关系模型的是美国 `IBM` 公司的 `E.F.Codd`：

* 1970年提出关系数据模型，之后，提出了关系代数和关系演算的概念。
* 1972年提出了关系的第一、第二、第三范式。
* 1974年提出了关系的 `BC` 范式。

****

## 2.1 关系数据结构及形式化定义

****

  按照数据模型的三个要素：

* 关系模型由关系数据结构；
* 关系操作集合；
* 关系完整性约束三部分组成。

下面将对这三部分内容进行分别介绍。

****

### 2.1.1 关系

****

  关系模型的数据结构非常简单，只包含单一的数据结构—关系。在用户看来，关系模型中数据的逻辑结构是一张扁平的二维表。

****

#### 域

****

* 是一组具有相同数据类型的值的集合。
* 例如：自然数、整数、实数的集合。

****

#### 笛卡尔积

****

* 给定一组域：$D_1, D_2, D_3, \dots, D_n$，且允许其中某些域是相同的
* 则其笛卡尔积为：$D_1 \times D_2 \times D_n \times \dots \times D_n = \{ (d_1, d_2, d_3 \dots, d_n)\ | \ d_i \in D_i, i = 1, 2, \dots , n \}$。
* 其中每一个元素 $(d_1, d_2, d_3 \dots, d_n)$ 叫做一个 $n$ 元组，或简称元组，其中 $d_i$ 为分量。

一个域允许的不同取值个数称为这个域的**基数**：

* 若 $D_i (i = 1, 2, \dots, n)$ 为有限集，其基数为 $m_i(i = 1, 2, \dots, n)$
* 则 $D_1 \times D_2 \times D_n \times \dots \times D_n$ 的基数 $M = \prod^{n}_{i = 1}m_i$。

笛卡尔积可以表示为一张二维表，表中的每行对应一个元组，表中的每一列的值来自一个域。

例如：

* 已知：$D_1 = X = \{ a, b \}, D_2 = Y = \{ c, d \}$

* 则 $D_1 \times D_2$ 的笛卡尔积为 $D_1 \times D_2 = \{ (a, c), (a, d), (b, c), (b, d) \}$

* 笛卡尔基数为 $2 \times 2 = 4$，共 $4$ 个元组，可生成表格如下：

* | $X$  | $Y$  |
  | :--: | :--: |
  | $a$  | $c$  |
  | $a$  | $d$  |
  | $b$  | $c$  |
  | $b$  | $d$  |

****

#### 关系

****

* $D_1 \times D_2 \times D_n \times \dots \times D_n$ 的子集叫做在域 $D_1, D_2, D_3, \dots, D_n$ 上的关系。
* 表示为 $R(D_1, D_2, D_3, \dots, D_n)$，其中 $R$ 为关系名，$n$ 为关系的目或度（Degree）。
* 关系中的每个元素是关系中的元组，通常用 $t$ 表示。
* 当 $n = 1$ 时，称该关系为单元关系（Unary relation）或一元关系，$n = 2$ 时称为二元关系（Binary relation）。

  **关系是笛卡儿积的有限子集**，所以**关系也是一张二维表，表的每行对应一个元组，表的每列对应一个域**。

****

#### 码

****

* 候选码（Candidate key）：若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码（如学号，身份证号）。
* 全码（All key）：在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码。
* 主码（Primary key）：若一个关系有多个候选码，则选定其中一个为主码。候选码的诸属性称为主属性（Prime attribute）。不包含在任何侯选码中的属性称为非码属性或非主属性（Non-key attribute）。

  **主码和候选码本质相同，只是数量不同**。

****

#### 三类关系

****

* 基本关系（基本表或基表）：实际存在的表，是实际存储数据的逻辑表示。
* 查询表：查询结果对应的表。
* 视图表：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。

****

#### 基本关系的性质

****

* 列同质的（Homogeneous）每一列中的分量是同一类型的数据，来自同一个域。
* 不同的列可出自同一个域：
  * 其中的每一列称为一个属性。
  * 不同的属性要给予不同的属性名。
* 列的顺序无所谓(属性名打破有序性）。
* 任意两个元组不能完全相同（候选码不同）。
* 行的顺序无所谓，即行的次序可以任意交换。
* 分量必须取原子值，每一个分量都必须是不可分的数据项。这是规范条件中最基本的。

****

### 2.1.2 关系模式

****

  在数据库中要区分型和值，关系数据库中：

* 关系模式（Relation Schema）是型，关系是值。

关系模式是对关系的描述：

* 元组集合的结构：
  * 属性构成
  * 属性来自的域
  * 属性与域之间的映象关系
* 完整性约束条件，元组语义。

  **关系的描述称为关系模式**（relation schema）。它可以形式化地表示为 $R(U, D, DOM, F)$：

* $R$ 为关系名
* $U$ 为组成该关系的属性名集合
* $D$ 为 $U$ 中属性所来自的域
* $DOM$ 为属性向域的映像集合
* $F$ 为属性间数据的依赖关系集合。

****

### 2.1.3 关系数据库

****

  在关系模型中，实体以及实体间的联系都是用关系来表示的。在一个给定的应用领域中，所有关系的集合构成一个关系数据库。

  关系数据库也有型和值之分：

* 关系数据库的型也称为关系数据库模式，是对关系数据库的描述。
* 关系数据库模式包括若干域的定义，以及在这些域上定义的若干关系模式。
* 关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。

****

### 2.1.4 关系模型的存储结构

****

- 有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成。
- 有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理。

****

## 2.2 关系操作

****

### 2.2.1 基本的关系操作

****

- 查询：
  * 基本操作：选择、投影、并、差、笛卡尔积；
  * 其他操作：连接、除、交，可由上述基本操作导出。
- 数据更新：插入、删除、修改。

关系操作的特点是集合操作方式：

* 操作的对象和结果都是集合。
* 这种操作方式也称为一次一集合(set-at-a-time)的方式。

相应地，非关系数据模型的数据操作方式则为一次一记录（record-at-a-time）的方式。

****

### 2.2.2 关系数据语言的分类

****

![](L:\02 学习笔记\数据库系统\图片2\操作语言.png)

**特点**：

- 关系语言是一种高度非过程化的语言，存取路径的选择由 `DBMS` 的优化机制来完成，用户不必用循环结构就可以完成数据操作。
- 能够嵌入高级语言中使用。
- 关系代数、元组关系演算和域关系演算三种语言在表达能力上完全等价。

****

## 2.3 关系的完整性

****

  关系模型中有三类完整性约束：

* 实体完整性(entity integrity)
* 参照完整性(referential integrity)
* 用户定义的完整性(user-defined integrity)。

  **关系模型必须满足实体完整性和参照完整性**，被称作是关系的两个**不变性**，应该由关系系统自动支持。

  用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。

****

### 2.3.1 实体完整性

****

* 若属性（指一个或一组属性）$A$ 是基本关系 $R$ 的主属性，则 $A$ 不能取空值（null value）。
* 所谓空值就是“不知道”或“不存在”或“无意义”的值。

**原因**：

1. 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
2. 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
3. 关系模型中以主码作为唯一性标识。
4. 主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性。

****

### 2.3.2 参照完整性

****

**外码**：  

* 设 $F$ 是基本关系 $R$ 的一个或一组属性，但不是关系 $R$ 的码，
* 如果 $F$ 与基本关系 $S$ 的主码 $K_s$ 相对应，则称 $F$ 是 $R$ 的外码。
* 基本关系 $R$ 称为参照关系（Referencing  Relation）
* 基本关系 $S$ 称为被参照关系（Referenced Relation）或目标关系（Target Relation）

关系 $R$ 和 $S$ 不一定是不同的关系，目标关系 $S$ 的主码 $K_s$ 和参照关系的外码 $F$ 必须定义在同一个（或一组）域上。

外码并不一定要与相应的主码同名；当外码与相应的主码属于不同关系时，往往取相同的名字，以便于识别。

**参照完整性规则**：

* 若属性（或属性组）$F$ 是基本关系 $R$ 的外码，它与基本关系 $S$ 的主码 $K$ 相对应（基本关系 $R$ 和 $S$ 不一定是不同的关系）
* 则对于 $R$ 中每个元组在 $F$ 上的值必须：
  * 取空值（$F$ 的每个属性值均为空值）
  * 或等于 $S$ 中某个元组的主码值

****

### 2.3.3 用户定义的完整性

****

- 用户定义的完整性是针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。
- 关系模型应提供定义和检验这类完整性的机制，以便用统一的系统的方法处理它们，而不要由应用程序承担这一功能。

****

## 2.4 关系代数

****

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。

运算具备以下要偶素：

* 运算对象
* 运算符
* 运算结果

**任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果**。

关系代数的运算对象是关系，运算结果亦为关系。关系代数用到的运算符包括两类：

* 集合运算符
* 专门的关系运算符

![](L:\02 学习笔记\数据库系统\图片2\运算符.png)

****

### 2.4.1 传统的集合运算

****

传统的集合运算是二目运算，包括并、差、交、笛卡儿积4种运算。

设关系 $R$ 和关系 $S$ 具有相同的目（即两个关系都有 $n$ 个属性），且相应的属性取自同一个域，$t$ 是元组变量，$t \in R$ 表示 $t$ 是 $R$ 的一个元组。可以定义并、差、交、笛卡儿积运算如下：

* 并（union）：
  * 关系 $R$ 与关系 $S$ 的并记作： $R \cup S = \{t |t \in R \land t \in S \}$
  * 其结果仍为 $n$ 目关系，由属于 $R$ 或属于 $S$ 的元组组成。
* 差（except）：
  * 关系 $R$ 与关系 $S$ 的差记作：$R - S = \{ t | t \in R \land t \notin S \}$
  * 其结果关系仍为 $n$ 目关系，由属于 $R$ 而不属于 $S$ 的所有元组组成。
* 交（intersection）：
  * 关系 $R$ 与关系 $S$ 的交记作 $R \cap S = \{ t | t \in R \land t \in S \}$ 
  * 其结果关系仍为 $n$ 目关系，由既属于 $R$ 又属于 $S$ 的元组组成。
  * 关系的交可以用差来表示，即 $R \cap S = R - ( R - S )$ 。
* 笛卡儿积（cartesian product）：
  * 这里笛卡儿积的元素是元组。
  * 两个分别为 $n$ 目和 $m$ 目的关系 $R$ 和 $S$ 的笛卡儿积是一个 $(n + m)$ 列的元组的集合。元组的前 $n$ 列是关系 $R$ 的一个元组，后 $m$ 列是关系 $S$ 的一个元组。
  * 若 $R$ 有个元组，$S$ 有 $2$ 个元组，则关系 $R$ 和关系 $S$ 的笛卡儿积有 $k_1 \times k_2$ 个元组。记作 $R \times S = \{\overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \}$

![](L:\02 学习笔记\数据库系统\图片2\传统集合运算.png)

****

### 2.4.2 专门的关系运算

****

专门的关系运算包括选择、投影、连接、除运算等。为了叙述上的方便，先引入几个记号：

* $R$，$t \in R$，$t[A_i]$
  * 设关系模式为 $R(A_1, A_2, \dots , A_n)$
  * 它的一个关系设为 $R$
  * $t \in R$ 表示 $t$ 是 $R$ 的一个元组
  * $t[A_i]$ 表示元组 $t$ 中相应于属性 $A_i$ 的一个分量
* $A$，$t[A]$，$\overline{A}$
  * 若 $A = \{ A_{i1}, A_{i2}, \dots , A_{ik} \}$，其中 $A_{i1}, A_{i2}, \dots , A_{ik}$ 是 $A_1, A_2, \dots , A_n$ 中的一部分，则 $A$ 被称为属性列或属性组。
  * $t[A] = (t[A_{i1}], t[A_{i2}], \dots , t[A_{ik}])$ 表示元组 $t$ 在属性列$A$ 上诸分量的集合。
  * $\overline{A}$ 则表示 $\{ A_1, A_2, \dots , A_n \}$ 中去掉 $A_{i1}, A_{i2}, \dots , A_{ik}$ 后剩余的属性组。
* $\overset{\frown}{t_r t_s}$
  * $R$ 为 $n$ 目关系，$S$ 为 $m$ 目关系
  * $t_r \in R$，$t_s \in S$， $\overset{\frown}{t_r t_s}$ 称为元组的连接
  * $\overset{\frown}{t_r t_s}$ 是一个 $n + m$ 列的元组，前 $n$ 个分量为 $R$ 中的一个 $n$ 元组，后 $m$ 个分量为 $S$ 中的一个 $m$ 元组
* 象集 $Z_x$
  * 给定一个关系 $R(X, Z)$， $X$ 和 $Z$ 为属性组
  * 当 $t[X] = x$ 时，$x$ 在 $R$ 中的象集（Images Set） 为：$Z_x = \{ t[Z] | t\in R, t[X] = x \}$
  * 它表示 $R$ 中属性组 $X$ 上值为 $x$ 的诸元组在 $Z$ 上分量的集合。

****

#### 选择

****

* 选择又称为限制（Restriction）
* 选择运算符的含义：
  * 在关系R中选择满足给定条件的诸元组
  * $\sigma_F(R) = \{ t | t \in R \land F(t) = `true' \}$
  * $F$：选择条件，是一个逻辑表达式，取值为“真”或“假”
  * 基本形式为：$X_1 \theta Y_1$
  * $\theta$ 表示比较运算符，它可以是 $\gt, \ge, \lt, \le, =, \ne$。
  * $X_1, Y_1$ 等是属性名、常量、简单函数；属性名也可以用它的序号来代替；
  * 在基本的选择条件上可以进一步进行逻辑运算，求非 ，与，或运算。

![](L:\02 学习笔记\数据库系统\图片2\选择.png)

****

#### 投影

****

* 从 $R$ 中选择出若干属性列组成新的关系
* $\Pi_A(R) = \{ t[A] | t \in R \}$
* $A$ ：$R$ 中的属性
* 投影操作主要是从列的角度进行运算
* 投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

![](L:\02 学习笔记\数据库系统\图片2\投影.png)

****

#### 连接

****

* 连接也称为 $\theta$ 连接
* 连接运算的含义：
  * 从两个关系的笛卡尔积中选取属性间满足一定条件的元组
  * $R \underset{A \theta B}{\bowtie} S = \{ \overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land t_r[A] \theta t_s[B] \}$
  * $A$ 和 $B$ ：分别为 $R$ 和 $S$ 上度数相等且可比的属性组
* 连接运算从 $R$ 和 $S$ 的广义笛卡尔积 $R \times S$ 中选取 $R$ 关系在 $A$ 属性组上的值与 $S$ 关系在 $B$ 属性组上的值满足比较关系 $\theta$ 的元组 

两类常用连接运算：

* 等值连接（equijoin）：
  * $\theta$ 为 $=$ 的运算
  * 从关系 $R$ 与 $S$ 的广义笛卡尔积中选取 $A,B$ 属性值相等的那些元组
  * $R \underset{A = B}{\bowtie} S = \{ \overset{\frown}{t_r t_s} | t_r \in R \land t_s \in S \land t_r[A] \theta t_s[B] \}$
* 自然连接（natural join）：
  * 自然连接是一种特殊的等值连接：
    * 两个关系中进行比较的分量必须是相同的属性组
    * 在结果中把重复的属性列去掉
  * 自然连接的含义：
    * $R$ 和 $S$ 具有相同的属性组 $B$
    * $R \bowtie S = \{ \overset{\frown}{t_r t_s} [U-B] | t_r \in R \land t_s \in S \land t_r[B] = t_s[B] \}$

一般的连接操作是从行的角度进行运算。

![](L:\02 学习笔记\数据库系统\图片2\连接.png)

​    **自然连接还需要取消重复列，所以是同时从行和列的角度进行运算**。 

****

#### 除运算

****

* 给定关系 $R(X, Y)$ 和 $S(Y, Z)$，其中 $X, Y, Z$ 为属性组。
* $R$ 中的 $Y$ 与 $S$ 中的 $Y$ 可以有不同的属性名，但必须出自相同的域集。
* $R$ 与 $S$ 的除运算得到一个新的关系 $P(X)$
* $P$ 是 $R$ 中满足下列条件的元组在 $X$ 属性列上的投影：
  * 元组在 $X$ 上分量值 $x$ 的象集 $Y_x$ 包含 $S$ 在 $Y$ 上投影的集合
  * $R \div S = \{ t_r[X] | t_r \in R \land \Pi_Y(S) \subseteq Y_x \}$
  * $Y_x$ ：$x$ 在 $R$ 中的象集，$x = t_r[X]$

**除操作是同时从行和列角度进行运算**

![](L:\02 学习笔记\数据库系统\图片2\除.png)

****

# 3. SQL 基础

****

## 3.1 SQL 简介

****

### 3.1.1 SQL 概念及特点

****

**基本概念**：

* `SQL`（**Structured Query Language：结构化查询语言**）用于管理关系数据库管理系统（`RDBMS`）。
* `SQL` 的范围包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。
* 这类数据库包括：`MySQL`、`SQL Server`、`Access`、`Oracle`、`Sybase`、`DB2` 等。
* `SQL` 在 `1986` 年成为 `ANSI`（American National Standards Institute 美国国家标准化组织）的一项标准，在 `1987` 年成为国际标准化组织（ISO）标准。

**特点**：

* 综合统一：集数据定义语言、数据操纵语言、数据控制语言的功能于一体，语言风格统一；
* 高度非过程化：无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成；
* 面向集合的操作方式：采用集合操作方式，增删改查操作的对象都可以是元组的集合；
* 以同一种语法结构提供多种使用方式：SQL 既是独立的语言，又是嵌入式语言；
* 语言简洁，易学易用：easy。

****

### 3.1.2 SQL 语言的类型

****

* 数据查询语言（DQL，Data Query Language）：基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。
* 数据操纵语言（DML，Data Manipulation Language）：是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。
* 数据库定义语言(DDL，Data Definition Language）：用于描述数据库中要存储的现实世界实体的语言。
* 数据库控制语言（DCL，Data Control Language）：用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。

我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）

****

### 3.1.3 SQL 基本约定

****

**SQL大小写不敏感**：

* `SQL` 对大小写不敏感：故 `SELECT` 与 `select` 是相同的，但仍建议将 `SQL` 命令语句纯大写字母书写，有如下优点：
  * 提高可读性：在 `SQL` 命令语句中使用纯大写可以使关键字、函数、表名等部分更加醒目，容易阅读和理解。
  * 统一规范：使用纯大写可以统一 `SQL` 命令语句的书写规范，方便代码的维护和修改。
  * 避免歧义：在 `SQL` 命令语句中使用纯大写可以避免大小写混用导致的语法错误和歧义。
* 虽然 `SQL` 对大小写不敏感，但是在 `SQL` 命令语句中使用纯大写仍然是一个良好的习惯和最佳实践。

 **SQL语句的分号和逗号**：

* 某些数据库系统要求在每条 `SQL` 语句的末端使用分号。
* 分号是在数据库系统中分隔每条 `SQL` 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 `SQL` 语句。
* 逗号通常用来分隔列名或表达式、值或子查询等元素。
* 至于某些长语句使用逗号，在不同的数据库系统中有不同的分隔规则。

**SQL支持注释**：

* 通过使用 `--` 或是 `#` 来编写注释内容，也可以使用 `/* 注释内容 */` 来进行多行注释。

****

### 3.1.4 MySQL 简介

****

* `MySQL` 为关系型数据库系统（Relational Database Management System）
* `MySQL` 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。
* `MySQL` 使用标准的 `SQL` 数据语言形式。
* `MySQL` 可以运行于多个系统上，并且支持多种语言。

****

## 3.2 基础语法

****

本节讲解 `SQL` 基础语法，具体语法示例则利用 `MySQL` 演示。

****

### 3.2.1 数据库定义语言（DDL）

****

#### 数据库操作

****

通过 `CREATE DATABASE` 来创建一个数据库：

```sql
CREATE DATABASE 数据库名
```

为了能够支持中文，我们在创建时可以设定编码格式：

```sql
CREATE DATABASE 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci
```

使用 `DROP DATABASE` 来删除一个数据库：

```sql
DROP DATABASE 数据库名
```

例如在 `MySQL` 中创建数据库Stu_Course：

```mysql
CREATE DATABASE Stu_Course;
```

在 `MySQL` 里切换并使用指定的数据库：

```mysql
USE Stu_Course;
```

设置字符集（如果创建时没有设定默认字符集，切换到需要修改的数据库下）：

```mssql
SET NAMES utf8mb4;
```

查看 `MySQL` 当前字符集：

```mysql
SHOW VARIABLES LIKE 'character_set%';
```

****

#### 创建表

****

数据库创建完成后，我们一般通过 `CREATE TALBE` 语句来创建一张表：

```sql
CREATE TABLE 表名(
    列名 数据类型[列级约束条件],
    列名 数据类型[列级约束条件],
             ...
    [,表级约束条件]
)
```

****

#### SQL数据类型

****

以下的数据类型用于字符串存储：

* CHAR(n)：可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。
* VARCHAR(n)：也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。

以下数据类型用于存储数字：

* SMALLINT：用于存储小的整数，范围在 (-32768，32767)；
* INT：用于存储一般的整数，范围在 (-2147483648，2147483647)；
* BIGINT：用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)；
* FLOAT：用于存储单精度小数；
* DOUBLE：用于存储双精度的小数；

以下数据类型用于存储时间：

* DATE：存储日期；
* TIME：存储时间；
* YEAR：存储年份；
* DATETIME：用于混合存储日期+时间；

****

#### 列级约束条件

****

列级约束有六种：

* 主键：PRIMARY KEY；
* 外键：FOREIGN KEY ;
* 唯一：UNIQUE；
* 检查：CHECK （MySQL不支持）；
* 默认：DEFAULT ；
* 非空/空值：NOT NULL/NULL。

****

#### 表级约束条件

****

表级约束有四种：主键、外键、唯一、检查

**例如**：

在 `MySQL` 中创建如下表：

| 列名    | 数据类型 | 宽度 | 允许空值 | 缺省值 | 主键 | 外键 | 说明   |
| ------- | -------- | ---- | -------- | ------ | ---- | ---- | ------ |
| Cno     | CHAR     | 4    | 否       |        | 是   |      | 课程号 |
| Cname   | CHAR     | 40   | 是       |        |      |      | 课程名 |
| Cpno    | CHAR     | 4    | 是       |        |      | 是   | 先行课 |
| Ccredit | SMALLINT |      | 是       |        |      |      | 学分   |

```mysql
CREATE TABLE Course (
	Cno CHAR(4) NOT NULL COMMENT '课程号',  # NOT NULL 非空约束；COMMENT '描述说明'
	Cname CHAR(40) NULL COMMENT '课程名',
	Cpno CHAR(4) NULL COMMENT '先行课',
	Ccredit SMALLINT NULL COMMENT '学分',
	PRIMARY KEY (Cno),  # 设置主键
	FOREIGN KEY (Cpno) REFERENCES Course(Cno)  # 设置外键关联
)ENGINE=INNODB DEFAULT CHARSET=utf8;  # ENGINE 设置存储引擎，CHARSET 设置字符集
```

****

#### 修改表

****

如果我们想修改表结构，我们可以通过 `ALTER TABLE` 来进行修改：

```sql
ALTER TABLE 表名 
	[ADD 新列名 数据类型[列级约束条件]]
	[DROP COLUMN 列名[restrict|cascade]]
	[ALTER COLUMN 列名 新数据类型]
```

* ADD：添加一个新的列
* DROP：删除一个列，支持可以添加restrict或cascade：
  * 默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除；
  * 而cascade会强制连带引用此列的约束、视图一起删除。
* ALTE：来修改此列的属性。

**例如**：

在 `MySQL` 中给Course表增加一列，字段名为Ctype（课程类型），类型为char，长度为10，允许为空值：

```mysql
ALTER TABLE Course 
ADD Ctype CHAR(10) NULL COMMENT '课程类型';
```

删除Ctype字段：

```mysql
ALTER TABLE Course 
DROP Ctype;
```

****

#### 删除表

****

我们可以通过`drop table`来删除一个表：

```sql
DROP TABLE 表名[restrict|cascade]
```

其中restrict和cascade上面的效果一致。

**例如**：

在 `MySQL` 中删除表 Course：

```mysql
DROP TABLE Course;
```

***

### 3.2.2 数据库操纵语言（DML）

****

#### 插入数据

****

使用 `INSERT INTO` 语句来向数据库中插入一条数据（一条记录）：

```sql
INSERT INTO 表名 VALUES(值1, 值2, 值3)
```

如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：

```sql
INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2)
```

我们也可以一次性向数据库中插入多条数据：

```sql
INSERT INTO 表名(列名1, 列名2) VALUES(值1, 值2), (值1, 值2), (值1, 值2)
```

**例如**：

在 `MySQL` 中的表格 SC 中：

| Sno       | Cno  | Grade |
| --------- | ---- | ----- |
| 200215121 | 1    | 92    |

插入一条数据 `{200215122, 2, 90}`

```mysql
INSERT INTO SC(Sno, Cno, Grade) VALUES(200215122, 2, 90);
```

****

#### 修改数据

****

我们可以通过 `UPDATE` 语句来更新表中的数据：

```sql
UPDATE 表名 SET 列名=值,... WHERE 条件
```

**例如**：

在 `MySQL` 中，将Course表中的课程号为“2”的学分改为4：

```mysql
UPDATE Course SET Ccredit=4 WHERE Cno='2';
```

****

#### 删除数据

****

我们可以通过使用 `DELETE` 来删除表中的数据：

```sql
DELETE FROM 表名
```

通过这种方式，将删除表中全部数据，我们也可以使用 `WHERE` 来添加条件，只删除指定的数据：

```sql
DELETE FROM 表名 WHERE 条件
```

**例如**：

在 `MySQL` 中，删除Course表中的课程号为“2”的数据：

```mysql
DELETE FROM Course WHERE Cno='2';
```

***

### 3.2.3 数据库查询语言（DQL）

****

#### 单表查询

****

单使用 `SELECT` 语句来进行单表查询：

```sql
# 指定查询某一列数据
SELECT 列名[,列名] FROM 表名

# 会以别名显示此列
SELECT 列名 别名 FROM 表名

# 查询所有的列数据
SELECT * FROM 表名

# 只查询不重复的值
SELECT DISTINCT 列名 FROM 表名
```

添加 `WHERE` 字句以限定查询目标，且支持正则表达式：

```sql
SELECT * FROM 表名 WHERE 条件
```

**例如**：

在 `MySQL` 中，在SC表中查询成绩大于90分的学生的学生全部信息：

```mysql
SELECT * FROM SC WHERE Grade > 90;
```

****

#### 常用查询条件

****

* 一般的比较运算符，包括 `=`、`>`、`<`、`>=`、`<=`、`!=` 等，其中 `!=` 也可以用 `<>` 表示；
* 是否在集合中：`IN`、`NOT IN`；
* 字符模糊匹配：`LIKE`，`NOT LIKE`；
* 多重条件连接查询：`AND`、`OR`、`NOT`；

**例如**：

在 `MySQL` 中，查询Student表中名字的第二个字是“雨”或“玉”的同学的学号Sno：

```mysql
SELECT Sno FROM Student WHERE Sname LIKE '_雨%' OR Sname LIKE '_玉%'; 
```

****

#### 排序查询

****

通过 `ORDER BY` 来将查询结果进行排序：

```sql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名 ASC|DESC
```

使用 `ASC` 表示升序排序，使用 `DESC` 表示降序排序，默认为升序。

也可以同时添加多个排序：

```sql
SELECT * FROM 表名 WHERE 条件 ORDER BY 列名1 ASC|DESC, 列名2 ASC|DESC
```

这样会先按照列名1的值进行排序，每组列名1相同的数据再按照列名2的值排序。

**例如**：

在 `MySQL` 中，在SC表中查询成绩大于90分的学生的学生全部信息并按照分数从大到小排序：

```mysql
SELECT * FROM SC WHERE Grade > 90 ORDER BY Grade DESC;
```

****

#### 聚集函数

****

聚集函数一般用作统计，包括：

* `COUNT([DISTINCT]*)`统计所有的行数（DISTINCT表示去重）；
* `COUNT([DISTINCT]列名)`统计某列的值总和；
* `SUM([DISTINCT]列名)`求一列的和（注意必须是数字类型的）；
* `SUM([DISTINCT]列名)`求一列的平均值（注意必须是数字类型）；
* `MAX([DISTINCT]列名)`求一列的最大值；
* `MIN([DISTINCT]列名)`求一列的最小值；

一般用法：

```sql
SELECT COUNT(DISTINCT 列名) FROM 表名 WHERE 条件 
```

**例如**：

在 `MySQL` 中，通过SC表计算“2”号课程的学生平均成绩、最高分、最低分：

```mysql
SELECT AVG(Grade) AS '平均成绩', MAX(Grade) AS '最高分', MIN(Grade) AS '最低分'
FROM SC
WHERE Cno = '2';
```

****

#### 分组和分页查询

****

通过 `GROUP BY` 来对查询结果进行分组，它需要结合聚合函数一起使用：

```sql
SELECT SUM(*) FROM 表名 WHERE 条件 GROUP BY 列名
```

添加 `HAVING` 来限制分组条件：

```sql
SELECT SUM(*) FROM 表名 WHERE 条件 GROUP BY 列名 HAVING 约束条件
```

添加 `LIMIT` 来限制查询的数量，只取前n个结果：

```sql
SELECT * FROM 表名 LIMIT 数量
```

查询数据很多可以对结果进行进行分页：

```sql
SELECT * FROM 表名 LIMIT 起始位置,数量
```

**例如**：

在 `MySQL` 中，汇总总分大于200分的学生的学号及总成绩：

```mysql
SELECT Sno, SUM(Grade) AS '总成绩'
FROM SC
GROUP BY Sno
HAVING SUM(Grade) > 200;
```

****

#### 多表查询

****

多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。

```sql
SELECT * FROM 表1, 表2
```

直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。

```sql
SELECT * FROM 表1, 表2 WHERE 条件
```

这样，只会从笛卡尔积的结果中得到满足条件的数据。

**注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。

#### 自身连接查询

自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：

```sql
SELECT * FROM 表名 别名1, 表名 别名2
```

其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。

#### 外连接查询

外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：

* 通过使用`inner join`进行内连接，只会返回两个表满足条件的交集部分：

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019053022120536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70)

* 通过使用`left join`进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用`null`来代替（右连接`right join`同理，只是反过来而已，这里就不再介绍了）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530221543230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg1ODIwMQ==,size_16,color_FFFFFF,t_70)

#### 嵌套查询

我们可以将查询的结果作为另一个查询的条件，比如：

```sql
SELECT * FROM 表名 WHERE 列名 = (SELECT 列名 FROM 表名 WHERE 条件)
```

我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。

***

### 3.2.4 数据库控制语言（DCL）

庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。

#### 创建用户

我们可以通过`create user`来创建用户：

```sql
CREATE USER 用户名 identified by 密码;
```

也可以不带密码：

```sql
CREATE USER 用户名;
```

我们可以通过@来限制用户登录的登录IP地址，`%`表示匹配所有的IP地址，默认使用的就是任意IP地址。

#### 登陆用户

首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：

```sql
login -u 用户名 -p
```

输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：

```sql
show databases;
```

我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！

#### 用户授权

我们可以通过使用`grant`来为一个数据库用户进行授权：

```sql
grant all|权限1,权限2...(列1,...) on 数据库.表 to 用户 [with grant option]
```

其中all代表授予所有权限，当数据库和表为`*`，代表为所有的数据库和表都授权。如果在最后添加了`with grant option`，那么被授权的用户还能将已获得的授权继续授权给其他用户。

我们可以使用`revoke`来收回一个权限：

```sql
revoke all|权限1,权限2...(列1,...) on 数据库.表 from 用户
```

***

#### 视图

视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。

我们可以通过`create view`来创建视图;

```sql
CREATE VIEW 视图名称(列名) as 子查询语句 [WITH CHECK OPTION];
```

WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用`select`语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。

1. 若视图是由两个以上基本表导出的，则此视图不允许更新。
2. 若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。
3. 若视图的字段来自集函数，则此视图不允许更新。
4. 若视图定义中含有GROUP BY子句，则此视图不允许更新。
5. 若视图定义中含有DISTINCT短语，则此视图不允许更新。
6. 若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade > (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。
7. 一个不允许更新的视图上定义的视图也不允许更新

通过`drop`来删除一个视图：

```sql
drop view apptest
```

***

#### 索引

在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：

```sql
-- 创建索引
CREATE INDEX 索引名称 ON 表名 (列名)
-- 查看表中的索引
show INDEX FROM student
```

我们也可以通过下面的命令删除一个索引：

```sql
drop index 索引名称 on 表名
```

虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。

***

#### 触发器

触发器就像其名字一样，在某种条件下会自动触发，在`select`/`update`/`delete`时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。

触发器所依附的表称为基本表，当触发器表上发生`select`/`update`/`delete`等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）

比如在`insert`操作时，新的内容会被插入到new表中；在`delete`操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在`update`操作时，旧的内容会被移到old表中，新的内容会出现在new表中。

```sql
CREATE TRIGGER 触发器名称 [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON 表名/视图名 FOR EACH ROW DELETE FROM student WHERE student.sno = new.sno
```

 FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！

通过下面的命令来查看触发器：

```sql
SHOW TRIGGERS
```

如果不需要，我们就可以删除此触发器：

```sql
DROP TRIGGER 触发器名称
```

***

#### 事务

当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：

```sql
SHOW ENGINES;
```

MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。

事务具有以下特性：

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

我们通过以下例子来探究以下事务：

```sql
begin;   #开始事务
...
rollback;  #回滚事务
savepoint 回滚点;  #添加回滚点
rollback to 回滚点; #回滚到指定回滚点
...
commit; #提交事务
-- 一旦提交，就无法再进行回滚了！
```

***

















# 4. 别急

****





















****

# 5. 别急

****

































****

# 6. 别急

****































****

# 7. 别急

****





































****

# 8. 别急

****



































